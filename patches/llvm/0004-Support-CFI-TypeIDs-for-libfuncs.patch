From 84cf0340f52753628566dd7c3810bcfc6d0d20f8 Mon Sep 17 00:00:00 2001
From: Koen Koning <koen.koning@intel.com>
Date: Thu, 27 Jul 2023 07:47:50 -0700
Subject: [PATCH 4/9] Support CFI TypeIDs for libfuncs.

This allows CFI systems to retrieve CFI TypeIDs for function calls that
were added during IR phase. Normally the frontend generates these
TypeIDs based on their mangled name, but this is not available in LLVM
(IR phase).
---
 .../include/llvm/Analysis/TargetLibraryInfo.h | 10 ++++++++++
 llvm/lib/Analysis/TargetLibraryInfo.cpp       | 20 +++++++++++++++++++
 llvm/lib/Transforms/Utils/BuildLibCalls.cpp   | 11 ++++++++++
 3 files changed, 41 insertions(+)

diff --git a/llvm/include/llvm/Analysis/TargetLibraryInfo.h b/llvm/include/llvm/Analysis/TargetLibraryInfo.h
index daf1d8e2079f..e45b8890dc0b 100644
--- a/llvm/include/llvm/Analysis/TargetLibraryInfo.h
+++ b/llvm/include/llvm/Analysis/TargetLibraryInfo.h
@@ -113,6 +113,12 @@ class TargetLibraryInfoImpl {
   bool isValidProtoForLibFunc(const FunctionType &FTy, LibFunc F,
                               const Module &M) const;
 
+  /// Return the mangled type name for a library function.
+  StringRef getMangledTypeNameForLibFunc(LibFunc F) const;
+
+  /// Return the CFI type id for a library function.
+  uint32_t getCFITypeIdForLibFunc(LibFunc F) const;
+
 public:
   /// List of known vector-functions libraries.
   ///
@@ -478,6 +484,10 @@ public:
     }
   }
 
+  uint32_t getCFITypeId(LibFunc F) const {
+    return Impl->getCFITypeIdForLibFunc(F);
+  }
+
   /// Returns extension attribute kind to be used for i32 parameters
   /// corresponding to C-level int or unsigned int.  May be zeroext, signext,
   /// or none.
diff --git a/llvm/lib/Analysis/TargetLibraryInfo.cpp b/llvm/lib/Analysis/TargetLibraryInfo.cpp
index 25951d2a7fe6..53194a5c6760 100644
--- a/llvm/lib/Analysis/TargetLibraryInfo.cpp
+++ b/llvm/lib/Analysis/TargetLibraryInfo.cpp
@@ -17,6 +17,7 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/TargetParser/Triple.h"
+#include "llvm/Support/xxhash.h"
 using namespace llvm;
 
 static cl::opt<TargetLibraryInfoImpl::VectorLibrary> ClVectorLibrary(
@@ -87,6 +88,16 @@ static const FuncProtoTy Signatures[] = {
 static_assert(sizeof Signatures / sizeof *Signatures == LibFunc::NumLibFuncs,
               "Missing library function signatures");
 
+
+static StringLiteral const MangledTypeNames[] = {
+#define TLI_DEFINE_TYPEMANGLED
+#include "llvm/Analysis/TargetLibraryInfo.def"
+};
+
+static_assert(sizeof MangledTypeNames / sizeof *MangledTypeNames == LibFunc::NumLibFuncs,
+              "Missing library function mangled type names");
+
+
 static bool hasSinCosPiStret(const Triple &T) {
   // Only Darwin variants have _stret versions of combined trig functions.
   if (!T.isOSDarwin())
@@ -1156,6 +1167,15 @@ bool TargetLibraryInfoImpl::getLibFunc(unsigned int Opcode, Type *Ty,
   return true;
 }
 
+StringRef TargetLibraryInfoImpl::getMangledTypeNameForLibFunc(LibFunc F) const {
+  return MangledTypeNames[F];
+}
+
+uint32_t TargetLibraryInfoImpl::getCFITypeIdForLibFunc(LibFunc F) const {
+  const StringRef TypeName = getMangledTypeNameForLibFunc(F);
+  return static_cast<uint32_t>(llvm::xxHash64(TypeName));
+}
+
 void TargetLibraryInfoImpl::disableAllFunctions() {
   memset(AvailableArray, 0, sizeof(AvailableArray));
 }
diff --git a/llvm/lib/Transforms/Utils/BuildLibCalls.cpp b/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
index 12741dc5af5a..3dbbf138027d 100644
--- a/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
+++ b/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
@@ -21,6 +21,7 @@
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/MDBuilder.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Type.h"
 #include "llvm/Support/TypeSize.h"
@@ -1356,6 +1357,16 @@ FunctionCallee llvm::getOrInsertLibFunc(Module *M, const TargetLibraryInfo &TLI,
 
   markRegisterParameterAttributes(F);
 
+  // Attach a CFI typeid to this function, for KCFI/FineIBT. Normally this is
+  // generated by the frontend already, but we may create new function
+  // prototypes here in the IR.
+  LLVMContext &Ctx = M->getContext();
+  auto Int32Ty = Type::getInt32Ty(Ctx);
+  auto CFITypeId = ConstantInt::get(Int32Ty, TLI.getCFITypeId(TheLibFunc));
+  MDBuilder MDB(Ctx);
+  F->setMetadata(LLVMContext::MD_cfi_type,
+                 MDNode::get(M->getContext(), MDB.createConstant(CFITypeId)));
+
   return C;
 }
 
-- 
2.34.1

